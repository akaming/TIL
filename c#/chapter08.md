논리(Logical) 및 조건(Conditional) 연산자
=============

<br>

논리 연산자(Logical Operator)
------
* 논리 연산자 AND와 OR는 비트 연산자 &와 |랑 비슷

|연산자|설명|반환값|
|-----|----|-----|
|&&|좌항과 우항이 모두 참인가?|좌항,우항이 모두 참이면 참<br>하나라도 참이 아니면 거짓|
| ｜｜ |좌항 혹은 우항이 하나라도 참인가?|좌항,우항 하나라도 참이면 참<br>둘다 참이 아니면 거짓|
|!|단항 연산자<br> 우항의 불리언 결과를 반대로 만든다|우항이 거짓이면 참,<br>우항이 참이면 거짓|

```
    int mathScore = 90;
    int englishScore = 100;

    (mathScore == 90) && (englishScore == 100)    // 참
    (mathScore < 90) || (englishScore == 100)  // 참

    !(mathScore == 90)    // 거짓
    !(englishScore == 90)    // 참
```
<br>

### 조건 연산자와 표현식 평가
* if문 안의 표현식들은 종종 평가되지 않을 때가 있음
```
    예시)

    if (1 + 1 == 2 || 1 + 2 == 2)
    {
        // 코드 생략
    }
```
* 이미 첫 번째 표현식이 참이므로 두번째 표현식은 평가할 필요가 없어짐
* 이거를 생각해서 다음 예시를 풀어보면
```
    예시)

    int num1 = 10;
    int num2 = 20;
    if (num1 == 10 || ++num2 == 20)
    {
        num1++;
    }

    Console.WriteLine($"{num1}, {num2}");  // 11, 20
```
* 첫 번째 표현식의 결과가 참이기 때문에 두번째 표현식이 실행되지 않음
* 따라서 ++num2를 실행하지 않아 num2의 값은 여전히 20 임

### AND 논리 연산자와 표현식 평가
```
    예시)

    if (1 + 1 == 2 && 1 + 2 == 2)
    {
        // 코드 생략
    }
```
* 첫 번째 표현식 결과가 참이지만 AND 논린 연산자는 두 번째 표현식 결과까지 봐야함 따라서 두 번째 표현식도 평가

```
    if (1 + 2 == 2 && 1 + 1 == 2)
```
* 이미 첫 번째 표현식이 거짓이므로 두 번째 표현식은 평가할 필요도 없음

<br>

조건 연산자
----
```
    if (num1 > num2)
    {
        max = num1;
    }
    else
    {
        max = num2;
    }
```
👆 위 예시를
```
    amx = (num1 > num2) ? num1 : num2;
```
이렇게 표현 가능 함

* 다른 말로는 삼항 연산자(Ternary Operator)라고도 함
    * ?와 : 이 두 기호를 사용
    * 불리언 표현식을 평가하여 참과 거짓일 때 서로 다른 반환값을 반환
```
    (불리언 표현식) ? 반환값1 : 반환값2    // 불리언 표현식이 참일 때 반환값1 실행 
                                        // 불리언 표현식이 거짓일 때 반환값 2 실행
```
* 매우매우 간단한 비교를 할 때만 조건 연산자를 사용하자
    * 이 경우는 if/else 문을 사용하는 것보다 빠를 수 있음
* **남용하지 말 것**
* 특히 조건 연산자 안에 조건 연산자를 쓸 경우 가독성이 떨어짐

<br>

연산자 우선순위
----
|연산자 종류|연산자 기호|연산자 결합법칙|
|:----------:|----------|:--------------:|
|후위(Postfix)|() [] -> . ++ - -|왼쪽에서 오른쪽|
|단항|+ - ! ~ ++ - - (type)* & sizeof|왼쪽에서 오른쪽|
|곱셈, 나눗셈|* / %|왼쪽에서 오른쪽|
|덧셈, 뺄셈|+ -|왼쪽에서 오른쪽|
|쉬프트(shift)|<< >>|왼쪽에서 오른쪽|
|관계(Relational)|< <= > >=|왼쪽에서 오른쪽|
|같음(Equality)|== !=|왼쪽에서 오른쪽|
|비트 연산자 AND|&|왼쪽에서 오른쪽|
|비트/논리 연산 XOR|^|왼쪽에서 오른쪽|
|비트 연산 OR|│|왼쪽에서 오른쪽|
|논리 연산 AND|&&|왼쪽에서 오른쪽|
|논리 연산 OR|││|왼쪽에서 오른쪽|
|조건(Conditional|?:|오른쪽에서 왼쪽|
|대입|= += -= *= /= %=>>= <<= &= ^= │=|오른쪽에서 오른쪽|
|콤마|,|오른쪽에서 오른쪽|

* 수학과 마찬가지로 대부분 연산자 결합 순서는 왼쪽에서 오른쪽
* 소수의 연산자만이 오른쪽에서 왼쪽
    * 예: 대입 연산자
    ```
        a = b = c + d 

        // 1. c와 d를 더하고
        // 2. 그 결과를 b에 대입
        // 3. 이제 b를 a에 대입
    ```

<br>

연산자 우선순위와 평가 순서는 다르다
----
```
    if(1 + 1 == 2 || 3 + 2 == 5 && 1 + 2 == 2)
    {
        //코드 생략
    }
```
* 우선순위는 &&가 || 보다 높음
* 하지만 다음 코드는 실행조차 되지 않음
    * 3 + 2 == 5
    * 1 + 2 == 5
* || 및 && 연산자는 왼쪽에 있는 표현식의 평가를 강제하기 때문에
    * 'C언어매니지드 언어' 과목에서 좀더 자세히 배움
    * 지금은 그냥 왼쪽 -> 오른쪽 으로 평가된다고 기억하기