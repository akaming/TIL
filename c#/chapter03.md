변수(Variable), 기본 자료형(Primitive Types)
=============

<br>

변수(Variable)란?
------
* 숫자, 문자와 같은 값들을 저장하는 공간
* 변할 수 있는 값을 의미

### 선언(Declaration)과 대입(Assignment)
```
    float numl;             //변수의 선언
    num1 = 128.512f;        // 변수의 대입

    float num2 = 20.8f;     // 변수의 선언과 대입이 동시에 이루어지는 경우

    const float PI = 3.14f; // const 변수(즉, 상수)는 항상 선언과 대입이 동시에 이루어짐
```
* 선언은 변수/상수의 자료형과 이름을 컴퓨터에게 알려줌
    * 변수/상수 및 자료형은 곧 다시 다를 예정
* 대입은 변수/상수의 실제 값을 컴퓨터에게 알려줌
* 선언과 대입을 동시에 할 수도 있음

### 변수는 숫자만 의미하지 않는다
* 'c'와 같은 문자나 "hello" 같은 문자열까지 변수에 포함
* 상수 또한 마찬가지

### 왜 변수를 사용해야 되나?
* 어딘가에 저장한 값을 다시 재사용하기 위해서
* 그래서 변수를 mutable(변할 수 있는, 잘 변하는) 이라고도 부름
* 그래서 상수는 immutable(변경할 수 없는, 불변의) 이라고도 부름

### 두 변수의 계산
* 예시 1
```
    using System;

    namespace Calculator2
    {
        class Program
        {
            static void Main(string[] args)
            {
                float num1 = 10.0f; //첫 번째 변수
                float num2 = 20.of; //두 번째 변수

                // 두 숫자 더하기
                Console.Write(num1 + "+" + num2 + "=");
                Console.WriteLine(num1 + num2);

                // 두 숫자 빼기
                Console.Write(num1 + "*" + num2 + "=");
                Console.WriteLine(num1 + num2);

                // 두 숫자 나누기
                Console.Write(num1 + "/" + num2 + "=");
                Console.WriteLine(num1 / num2);
            }
        }
    }
```
* 코드 재사용성이 높아짐
* 유지보수 쉬움

<br>

* 예시2
```
    // 매직 넘버를 쓸 경우
    using System;

    namespace Age1
    {
        class Program
        {
            static void Main(string[] args)
            {
                Console.WriteLine(17);
            }
        }
    }
```

```
    // 명확한 이름을 가진 변수를 쓸 경우
     using System;

    namespace Age1
    {
        class Program
        {
            static void Main(string[] args)
            {
                int age = 17;
                Console.WriteLine(age);
            }
        }
    }
```
* 다른 사람이 볼때 이 코드가 어떤거를 의미하는지 명확히 알 수 있음

<br>

변수명 짓기 팁, const 키워드
------
### 코팅 스탠다드 : 변수명은 명확하게 지을 것
* 명사로 정확하게 어떤 정보를 담는지 알려주는 단어를 사용
    * 성적이면: score
    * 이름이면: name
* 여러 명사가 들어간다면 두번째 단어의 첫 글자는 대문자로 (camelCasing)
    * 수학성적이면: mathScore
    * 사과 갯수면: appleCount

### const 키워드
* constant의 줄임말 -> 즉, 상수!
* 한번 값을 대입 한 후에 값을 바꾸고 싶지 않을 때 사용
```
    const int appleCount = 17;
    appleCount = 100;
```
* 대입 후, 값을 변경할 경우 컴파일 오류가 발생

### 코딩 표준: 변수와 상수의 이름

|변수|상수|
|----|----|
|명사를 사용하여 **소문자**로 작성<br>예) score,number|명사를 사용하여 **대문자**로 작성<br> 예) SCORE,NUMBER|
|여러 명사가 들어간다면, 두 번째 단어의 첫 단어는 대문자로 작성<br>예) mathScore,appleCount|여러 명사가 들어간다면 명사 사시에 밑줄 기호(_)를 사용<br> 예) MATH_SCORE, APPLE_COUNT|

### 코딩 표준을 적용한 사과와 오렌지 개수 출력하기
```
    static void Main(string[] args)
    {
        const int APPLE_COUNT = 17;
        cosnt int ORANGE_COUT = 20;

        Console.WriteLine(APPLE_COUNT + ORANGE_COUT);
    }
```

<br>

기본 자료형(Primitive Types)
------
* 정수, 실수, 문자 등과 같이 프로그램에서 사용되는 자료(data)의 종류를 의미
* 컴퓨터가 이해할 수 있는 가장 자연스러운 형태의 데이터
    * 전부 다 숫자
    * 디지털은 0과 1
    * 컴퓨터는 디지털
        * 0과 1로만 사용해서 표현을 해야함
        * 10진수는 10개의 수(0~9)를 사용함
        * 2진수는 2개의 수(0,1)를 사용함
        * 10진수와 2진수는 수학 코스에서 다룰 예정

### 자료의 크기
* 최소 단위는 비트(bit
    * 1 혹은 0을 담을 수 있음. 그것도 한 개만
* 8비트가 모이면 바이트(byte)
    * 각 비트는 마찬가지로 하나의 1혹은 0을 담을 수 있음
* 1024 바이트 = 1킬로 바이트(KB)
* 1021 킬로바디으 = 1메가 바이트(MB)

### 정수형(Integer Types)
* 0,1,2,3 과 같은 정수를 담을 수 있는 자료형
* byte, short, int, long
* 프로그래밍 언어마다 담을 수 있는 자료의 크기 차이는 존재

C#에서 각 자료형의 크기
|자료형 이름|자료형 크기|
|----------|----------|
|byte|8비트|
|short|16비트|
|int|32비트|
|long|64비트|


### 부동소수점형(Floating-Point Types)
* 3.14,0.9와 같은 실수를 담을 수 있는 자료형
* float, double
* 프로그래밍 언어마다 담을 수 있는 자료의 크기 차이는 존재
C#에서 각 자료형의 크기
|자료형 이름|자료형 크기|
|----------|----------|
|float|32비트|
|double|64비트|

### 문자형(Character Type)
* 하나의 문자를 담는 자료형
    * 알파벳(a-z, A-Z), 숫자(0-9), 특수문자(!,@,* 등등)
    * 문자를 감쌀 때 작은 따옴표(')를 사용
        * 예시) 'a' '1' '-'
* char
* C#이 char를 조금 특이하게 다룸
    * 이유는 C#에서는 char가 유니코드 이기 때문

C#에서 각 자료형의 크기
|자료형 이름|자료형 크기|
|----------|----------|
|char|16비트|


### 불리언형(Boolean Type)
* 참(true)과 거짓(false)을 표현하는 자료형
* bool
* C++과 같은 일부 언어에서는 false를 0으로 true를 0이 아닌 값으로 변환이 가능
    * C#에서는 불가능

### C#에서의 기본 자료형
|자료형 이름|자료형 크기|
|----------|----------|
|byte|8비트 정수|
|char|16비트 문자(이 강의에서는 자세하게 다루지 않음)|
|short|16비트 정수|
|int|32비트 정수|
|long|64비트 정수|
|float|비트 실수|
|double|비트 실수|

<br>

코드보기 : 기본자료형으로 선언한 변수
------
* int 
    * int int1 = 2;
    * int int2 = 10;
* float
    * float float1 = 10.23f;
    * float float2 = 3.4f;
* double
    * double double1 = 11.0;
    * double double2 = 5.234;
* char
    * char char1 = 'x';
    * char char2 = '$';

<br>

각 자료형마다 비트수가 다른 이유
------
* 한 개의 비트로는 2개의 수(0,1)을 표현 할수 있음

### C# 정수형을 다시 살펴보면

|자료형 이름|자료형 크기|
|----------|----------|
|byte|8비트|
|short|16비트|
|int|32비트|
|long|64비트|

* byte의 경우 2의8승 = 256개의 숫자를 표현 가능
* short의 경우 2의16승 = 65,536개의 숫자를 표현 가능
* int의 경우 2의32승 = 4,294,967,296개의 숫자를 표현 가능
* long의 경우 2의64승 = 18,446,744,073,709,551,616개의 숫자를 표현 가능


### 컴퓨터는 음수를 표현할수 없는가
* 예를 들어 여기 byte(8비트)가 있다고 하면은 총 256개의 숫자를 표현할 수 있음(2의8승)
    * 0부터 시작하면은 [0,255], 1부터 시작하면은 [1,256]
    * 기본적으로는 0부터 시작 함
    * 여기서 어떻게 음수/양수를 배분할까?
        * 반반으로 나누면 됨
        * 근데 0 빼고 255개 남아서 딱 반이 안되어서 음수가 하나 더 그냥 갖기로 함
* 결론
    * [-128,127]
        * 양수 : [1,127]
        * 0
        * 음수 : [-128,-1]
    * 127을 이진수로 나타내면<br>
        0 1 1 1 1 1 1 1
    * 양수 <br>
        **0**000 0001 ~ **0**111 1111
    * 0 <br>
        0000 0000
    * 음수 , 음수는 언제나 앞에 1로 표현<br>
        **1**000 0000 ~ **1**111 1111
* 최상위 비트를 이용해서 음수/양수를 구분하기로 **약속**
    * 최상위 비트의 값이 **0**이면 양수
    * 최상위 비트의 값이 **1**이면 음수

<br>

부호 있는 자료형(Signed Types), 부호 없는 자료형(Unsigned Types)
------

### 부호 있는 자료형
* 음수와 양수를 모두 표현

|자료형 이름|자료형 범위|
|----------|----------|
|sbyte|-128 ~ 127|
|short|-32,768 ~ 32,767|
|int|-2,147,483,678 ~ 2,147,483,647|
|long|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|

### 부호 없는 자료형
* 양수만 표현
* 보통 부호 있는 자료형 이름 앞에 'u'를 붙임

|자료형 이름|자료형 범위|
|----------|----------|
|byte|0 ~ 255|
|ushort|0 ~ 65,535|
|uint|0 ~ 4,294,967,295|
|ulong|0 ~ 18,446,744,073,709,551,615|

* 왜 **byte**만 부호 없는 쪽이 기본일까?
    * 그냥 외우기

### 확장 아스키(Extended ASCII)
* 기존 128개의 문자 다음에 원하는 문자들을 코드에 추가
* OEM 437(불어/독어 등등),EUC-KR(한국어),EUC-JP(일본어)
    * 그래서 문자를 담는 8비트 문자형들은 unsigned가 좀더 말이 됨

### 결론
* 그렇기 때문에 **C#에서** 그냥 byte하면은 unsigned , sbyte하면은 음수/양수 모두 
담는 signed

자료형을 언제 쓸까?
------
### 부호 있는 변수와 없는 변수는 언제 쓰나?
* 부호 있는 변수와 부호 없는 변수는 굉장히 중요
    * 프로그래머의 명백한 의도를 보여주기 때문
* 예를 들어서 여기 변수 하나가 있음
```
    int age = 17;
```
* 위에 처럼 쓰면은 age에 -가 들어갈수도 있고 +가 들어갈수도 있기 때문에 헷갈리기 때문에
* 변수형은 int형으로 부호 있는 자료형을 써야 된다.
### 오버플로우(overflow)
* 연 산의 결과로 자료형보다 큰 수가 나오는 경우를 말함
* 자료형의 크기는 변하지 않기 때문에 넘어가버린 비트는 버림
* 오버플로우가 발생할 경우 원치 않는 값이 나올수 있음

### 변수의 자료형을 선택할 때 주의할 점
* 변수의 역할에 알맞은 자료형을 선택할 것
* 오버플로우를 고려해서 자료형을 선택할 것

<br>

상수의 접두사와 접미사
------
* 접두사와 접미사는 상수의 앞이나 뒤에 상수를 꾸미는 기호

### 상수 접두사
* 상수앞에 붙는 기호로 진법을 나타냄
* 2진수 (**B**inary)
    * 0b/0B - (일반적으로는 소문자로 씀 0b 이렇게)
    ```
        int num1 = 0b10;
        int num2 = 0B10;
    ```
    위의 예시인 0b10을 보면은 0b는 2진수 라는것을 뜻함 즉, 1 0 이라는 2진수 임
    하지만 출력할때는 10진수로 출력되기 때문에 2진수의 1 0 은 10진수로 표현하면은 2 이기 때문에 2가 나옴
    결국에 num1 의 값은 2 이다.
<br>

* 16진수 (He**x**adecimal)
    * 0x- / 0X- (일반적으로는 소문자로 씀 0x 이렇게/ 굉장히 많이 쓰는 표현)
    ```
        int num1 = 0x10;
        int num2 = 0x10;
    ```
    * 위의 예시인 0x는 16진수 라는것을 뜻함. 즉 16진수 10 이기 때문에 이거를 10진수로 표현하면은 16이 출력된다. 이해가 안된다면 밑에 있는 16진수 표를 보자

* 16진수 표

|10진수|16진수|
|-----|-----|
|0|0|
|1|1|
|2|2|
|3|3|
|4|4|
|5|5|
|6|6|
|7|7|
|8|8|
|9|9|
|10|A|
|11|B|
|12|C|
|13|D|
|14|E|
|15|F|
|16|10|
|17|11|
|18|12|
|19|13|
|20|14|
|21|15|
|22|16|
|23|17|
|24|18|
|25|19|
|26|1A|
|27|1B|
|28|1C|
|29|1D|
|30|1E|


<br>

### 상수 접미사
* 상수 뒤에 붙는 기호로 상수의 형을 나타냄
* 부호 여부
    * -u (Unsigned)
    ```
        int num1 = 10;
        uint num2 = 10u;
        uint num3 = 0x10u;
    ```
* long
    * -l
    ```
        int num1 = 1l;    //컴파일 오류
        long num2 = 10l;
        long num3 = 10lu; //컴파일 오류
        ulong num4 = 10lu;
    ```
* float
    * -f/-F
    ```
        float num1 = 10.0f;
        float num2 = 10.0F;
        float num3 = 10.0;   //컴파일 오류
    ```
* double
    * 없음 혹은 -d/-D
    ```
        double num1 = 10.0;
        double num2 = 10.0d;
        double num3 = 10.0D;
    ```