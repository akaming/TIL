재귀 함수, 그리고 주사위 굴리기(랜덤 수 생성)
=====

재귀 함수(Recursive Function)란?
-----
### 재귀 함수(recurisve function)
* 이미 해결한 작은 문제에 어부바~해서 더 큰 문제를 해결하는 방법
* 예: 1에서 5까지의 합을 구하려는데
    * 이미 1~4까지 더한 결과 10임을 알고 있음
    * 그러면 여기에 5만 더 하면 15가 됨
* 프로그래밍에서는 함수 A가 매개변수만 바꾸어 다시 함수 A를 호출하는 방법으로 구현

<br>

재귀 함수의 구성요소
----
* 종료 조건(endding condition, base case)
    * 더 이상 재귀 함수를 호출하지 않고 값을 반환하는 조건
    * 매우 간단히 함수의 반환 값을 찾을 수 있는 경우
    * 이것이 없으면 함수를 무한히 재귀적으로 호출
* 재귀적 함수 호출
    * 종료조건이 아닌 경우
    * 함수의 인자를 바꿔 스스로를 다시 호출
    * 이 때, 함수의 인자는 현재 문제보다 작은 문제를 대표해야 함
    * 즉, 동일한 동작을 보다 작은 문제에 적용

### 재귀 함수의 구성요소
```
    static uint SumRecursive(uint num)
    {
        if (num == 0)
        {
            return 0;
        }
        // 👆 종료 조건
        else
        {
            return SumRecursive(num - 1) + num;
        }
        // 👆 재귀 호출
    }
```

<br>

반복문과의 비교
----
### 반복문이 더 쉽다
* 매우 단순한 문제는 당연히 반복문이 쉬움
```
    // 반복문
    satic uint Sum(uint num)
    {
        uint sum = 0;
        for (uint i = 0; i < num;  ++i)
        {
            sumt += i;
        }

        return sum;
    }
```
```
    // 재귀 함수
    static uint SumRecursive(uint num)
    {
        if (sum == 0)
        {
            return 0;
        }
        else 
        {
            return SumRecursive(num - 1) + num;
        }
    }
```

### 반복문을 그냥 쓰면 안되나?
* 사실 모든 재귀 함수는 반복문을 해결 가능
* 그러나 복잡한 문제일수록 재귀 함수가 더 편함
    * 이진 검색
    * 트리 구조
    * 퀵 정렬
    * 하노이의 탑
    * 어떤 폴더 아래에 있는 모든 파일 목록 구하기

<br>

피보나치 수열로 이해하는 재귀 함수
---
### 피보나치 수열
* 제 0항은 0, 제 1항은 1이며, 그 뒤의 모든 항은 바로 앞 두항의 합인 수열
    |0|1|1|2|3|5|8|13|21|34|55|...|
* 수학적 정의
    * F₀ = 0,
    * F₁ = 1,
    * F𝚗 = F𝚗₋₁ + F𝚗₋₂(n > 1)


### 피보나치 수
```
    public static int FibonacciRecursive(uint number)
    {
        if (number == 0)
        {
            return 0;
        }
        if (number == 1)
        {
            return 1;
        }
    }
```
* 함수는 신뢰의 문제라고 말했음
* 재귀 함수는 더 큰 신뢰를 요구
* Fibonacci(4)를 구하려 할때
    * Fibonacci(2), Fibonacci(3)은 반드시 올바른 값을 반환한다 믿어야 함
    * 왜냐면 수학적 귀납법으로
    * 다른 말로 하면 종료 조건: Fibonacci(0)은 0, Fibonacci(1)은 1을 반드시 반환
    * 그 후의 수는 위 종료 조건에 기초하여 값을 계산할 수 있음

### 그래도 반복문이 더 쉽다
* 이렇게 말 한다면 수학적 귀납법에 익숙지 않기 때문일지도
```
    // 반복문
    public static uint FibonacciIterative(uint number)
    {
        uint[] list = nuew uint[number + 1];

        list[0] = 0;
        list[1] = 1;
        
        for (uint i = 2; i <= number; ++i)
        {
            list[i] = list [i - 2] + list[i - 1];
        }

        return list[number];
    }
```
```
    // 재귀함수
    public static int FibonacciRecursive(uint number)
    {
        if  (number == 0)
        {
            return 0;
        }
        if (number == 1)
        {
            return 1;
        }
        return FibonacciRecursive(number -2) + FibonacciRecursive(number - 1);
    }
```

### 더 복잡한 문제는 당연히 재귀문이 더 쉽다
폴더의 목록을 가져오는 함수(의사 코드)
```
    //GetDirectoryNames(path): path 안에 있는 모든 폴더의 이름을 가져오는 함수
    //GetFileNames(path): path 안에 있는 모든 파일의 이름을 가져오는 함수
    static string[] GetFileNamesRecursive(string path)
    {
        filesNames += GetFileNameRecursive(directoryNames[i]);
    }
    filesNames += GetFileNames(path);
    return filesNames;
```

<br>

수학적 귀납법으로 이해하는 재귀 함수
----
### 재귀적 해결법 = 논리력
* 프로그래머의 논리력을 평가하기에 적합
* 매우 큰 문제를 작게 쪼개서 증명할 수 있나
    * 절대 틀릴 수 없는 최소한의 문제를 품
    * 최소한 문제의 해법에 의존하여 그 보다 하나 더 큰 문제를 해결
    * 그 과정을 반복하면 논리적으로 최종 문제까지 해결
* 수학적 귀납법과 매우 밀접

### 하노이의 탑으로 이해하는 재귀 함수
1. 막대 세 개가 있고, 한 막대에 n개의 원판이 있음
    * n개의 원판에서 상위 n-1개를 다른 막대에 옮길 수 있다고 가정
        * n-1개의 원판을 중간 막대로 옮김
        * 마지막 n번째 원판은 목적지 막대에 옮김
        * 중간 막대에 있던 n-1개의 원판을 목적지 막대에 옮김
2. 막대 세 개가 있고, 한 막대에 n-1개의 원판이 있음
    * n-1개의 원판에서 상위 n-2개를 다른 막대에 옮길 수 있다고 가정
        * n-2개의 원판을 중간 막대로 옮김
        * 마지막 n-1 번째 원판은 목적지 막대에 옮김
        * 중간 막대에 있던 n-2개의 원판을 목적지 막대에 옮김
3. 막대 세 개가 있고, 한 막대에 2개의 원판이 있음
    * 2개의 원판에서 상위 1개를 다른 막대에 옮길 수 있다고 가정
        * 1개의 원판을 중간 막대로 옮김
        * 마지막 2번째 원판은 목적지 막대에 옮김
        * 중간 막대에 있던 1개의 목적지 막대에 옮김
4. 막대 세 개가 있고, 한 막대에 1개의 원판이 있음
    * 1개의 원판을 다른 막대에 옮길 수 있음(한개니까)
        * 1개의 원판을 목적지 그대로 옮김

<br>

재귀 함수의 장단점과 베스트 프랙티스
-----
### 재귀 함수의 장점
* 개념적으로 매우 훌륭함
* 증명이 가능함

### 재귀 함수의 단점
* 효율성이 떨어짐
* 반면에 반복문은 그런 문제가 없음
    * 이전 연산의 결과를 저장(캐싱)하기 때문

### 재귀 함수의 단점 - 스택 오버플로우
* 함수 호출 깊이에는 제한이 있음
* 컴퓨터 구조 과목에서 좀 더 자세히 설명

### 베스트 프랙티스
* 캐싱 없이 간단한 반복문으로 작성 가능한 문제는 반복문으로
    * 예: 1 ~ N까지 수의 합 구하기
* 그 외에는 재귀 함수로 우선 작성
    * 설계 및 이해가 용이하기 때문
* 다음의 경우에는 반복문으로 코드 리팩토링(code refactoring)
    * 함수 호출의 최대 깊이를 확정할 수 없음
    * 또는, 성능상의 문제를 발견

<br>

랜덤 수 생성
----
* 난수 생성이라고도 함
* 언제나 예측 가능했던(deterministic)컴퓨터 세상에 내린 단비
* 이 덕에 게임이 나올 수 있었음
* 거의 모든 프로그래밍 언어에 존재하는 개념

### Random 클래스와 개체 생성
```
    Random random = new Random();

    * Random 은 클래스
    * random 은 Random형 개체의 이름(변수)
    * new Random(); 은 Random형 개체를 생성
```
* '랜덤 생성기를 만들어 random 이라는 변수에 대입한다' 라고만 기억
* random은 변수명이므로 다른 단어를 써도 무방
    ```
        Random luck = new Random();   // Ok
    ```
* 클래스와 개체가 무엇인지는 나중에 배울 예정
    * 클래스 : 지금은 '여러개의 함수가 뭉쳐있는 집합'정도로만 기억
    * 개체: 지금은 '클래스 안에 있는 함수를 사용하려면 필요하다' 정도로만 기억

### 난수 생성하기
```
    Random random = new Random();    // 반드시 필요한 코드
    int number1 = random.Next(3);
    int number2 = random.Next(1, 10);
```
```
    <변수명>.Next(<최대값>);
```
* 0 이상 최댓값 미만의 수 중 하나를 무작위로 뽑아줌 → [0, 최댓값]
    ```
        <변수명>.Next(<최솟값>, <최댓값>);
    ```
* 최솟값 이상 최댓값 미만의 수 중 하나를 무작위로 뽑아줌 → [최솟값, 최댓값]

<br>

랜덤 수 생성 2
----
### 의사 랜덤(pseufo random)
* 대부분 언어에서 지원하는 랜덤은 진정한 랜덤이 아님
* 시드(seed) 값을 초기 입력값으로 하여 알고리즘을 통해 "난수"를 만들어 내는 함수
* 그 결과는 다시 랜덤의 입력값이 됨
* 이 말은 시드 값이 같으면 언제나 생성된 난수의 순서가 동일

<br>

랜덤 수 생성 3
----
### 의사 랜덤(pseufo random)
* 여러 알고리즘이 존재
* 대부분의 알고리즘은 완벽하게 랜덤이 아님
    * 알고리즘의 효율성은 난수의 분포로 결정
    * 완벽한 난수 생성기를 만들려는 움직임도 있었지만 망했음

### new Random()은 괜찮았는데 왜 그럴까?
* 이런 문제를 해결하기 위해 컴퓨터에 달린 시계를 시드값으로 이용
* new Random()도 내부적으로 그럼
* 이걸 직접 안 해주는 언어에서는 직접 시간을 읽어서 시드값으로 넣어줌

### 그럼 고정된 시드값은 쓸모 없는 건가?
* 시드값을 고정시키면 좋은 경우가 있음
* 랜덤 수에 기초한 프로그램 로직에서 문제가 발생한 경우
    * 똑같은 시드값을 넣고 개발자 기계에서 실행하면 그대로 문제 재현
* 네트워크로 연결된 두 사용자가 게임을 할때
    * 동일한 시드값을 각 컴퓨터에 넣어주고 난수를 동일한 횟수만큼 생성
    * 그러면 난수에 의해 바뀌는 게임 속 로직도 두 컴퓨터에서 동일
    